{"noir_version":"0.23.0+5be9f9d7e2f39ca228df10e5a530474af0331704","hash":14389199202967643714,"abi":{"parameters":[{"name":"criteria","type":{"kind":"struct","path":"AccessControlCriteria","fields":[{"name":"conditions","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"Condition","fields":[{"name":"name","type":{"kind":"string","length":10}},{"name":"operator","type":{"kind":"string","length":2}},{"name":"value","type":{"kind":"field"}},{"name":"issuer","type":{"kind":"string","length":8}}]}}},{"name":"combinations","type":{"kind":"array","length":1,"type":{"kind":"string","length":1}}}]},"visibility":"private"},{"name":"credential","type":{"kind":"struct","path":"UnifiedCredential","fields":[{"name":"claims","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"Claim","fields":[{"name":"name","type":{"kind":"string","length":10}},{"name":"value","type":{"kind":"field"}},{"name":"issuer","type":{"kind":"string","length":8}}]}}}]},"visibility":"private"}],"param_witnesses":{"credential":[{"start":43,"end":81}],"criteria":[{"start":0,"end":43}]},"return_type":null,"return_witnesses":[]},"bytecode":"H4sIAAAAAAAA/+2dB3Rc1RGGZyVb1qoX9467cdvVSivJvRsbNwwYY6plyWACtpBlqum992IwzfTeuwkECBAgQIAAAQIEAgECBAgQIJTsmN3k6mbNiuN/nu8c3z3nndWAzrz/n7n65r717r51IaLyLFr/SPxIyR8p14hDVpxlxdlW3MaK21pxjhW3s+JcKw5bcZ4V51txoRUXWXGxFZdYcakVl1lxuRW3t+IOVtzRijtZcWcr7mLFXa24mxV3t+IeVtzTintZcW8r7mPFfa24nxX3t+IBVjzQigdZ8WAr3tKKh1jxUCseZsXDrXiEFUesOGrFFVYcs+JKK45bcbUV11hxrRWPtOJRVjzaisdY8VgrHmfF4614ghVPtOJJVjzZiqdY8VQrnmbF0614hhVvbcUzrXiWFc+24jlWPDcZm4/s5PP45HMsEq+sbKiuaIjGoosiFbV1NVWRyqq6eE20JlpVU1VfUROLNdRU1lTX1tVWR2qjlbGG6JKq2tiSyE8PM1dk4x7RIUBd2+B0RbKTNbUfIauWkY17RJGaTb3z6KdZRPS/uWauhRwBL2Sdx65fUZr/Bj25RHPmCeTdlrB/jBK+t8X3KELWAiFgHUJA/0OBurYjfVBCajb1bk8eSpDmbC+Qdz65DSX2PR/fI1EoZQH9DwPq2oH0QQmp2dS7gDyUIM1ZIJB3R3IbSux7R3yPRLTyjm5+mrwbW9eFpAPG2cBaDgfq2on0wRip2dS7M3kYQ5qzs0DeXchtGLPvXfA9EtHKQ2Mh4WG8K+mAcRtgLUcAde1G+mCM1Gzq3Z08jCHN2V0g7yJyG8bsexG+RyJaeWjsSngY15EOGLcF1jIC1LWY9MEYqdnUW08expDm1AvkbSC3Ycy+G/A9EtHKQ6OO8DBeQjpgnAOsZRSoaw/SB2OkZlPvnuRhDGnOngJ5l5LbMGbfS/E9EtHKQ2MJ4WG8F+mAcTtgLSuAun5F+mCM1Gzq3Zs8jCHN2Vsg7z7kNozZ9z74Holo5aGxF+FhvIx0wDgXWMsYUNdy0gdjpGZTbyN5GEOa0yiQd19yG8bse198j0S08tBYRngYN5EOGIeBtawE6lpB+mCM1GzqbSYPY0hzmgXyriS3Ycy+V+J7JKKVh0YT4WG8H+mAcSGwlnGgrv1JH4yRmk29B5CHMaQ5BwjkPZDchjH7PhDfI1EoFQH9VwN1HUT6oITUbOo9mDyUIM05WCDvKnIbSux7Fb5HolAqBvqvAeo6hPRBCanZ1HsoeShBmnOoQN7DyG0ose/D8D0S0co7ulWEv2w9nHTAuARYy1qgriNIH4yRmk29R5KHMaQ5RwrkPYrchjH7PgrfIxGtPDQOJzyMjyYdMC4F1nIkUNcxpA/GSM2m3mPJwxjSnGMF8h5HbsOYfR+H75GIVh4aRxMexseTDhiXAWs5CqjrBNIHY6RmU++J5GEMac6JAnlPIrdhzL5PwvdIRCsPjeMJD+OTSQeMy4G1HA3UdQrpgzFSs6n3VPIwhjTnVIG8p5HbMGbfp+F7JKKVh8bJhIfx6aQDxu2BtRwD1HUG6YMxUrOp90zyMIY050yBvGeR2zBm32fheySilYfG6YSH8dmO++b3Be8n4Pscx33zujxbwPe5JDN8s8A684C5zoN5jtUHNTBxmlsOzPPJD0xIc84XyLua3B6Y7Hs1vkeiIMkH5roA5rkisJ03TnNLkFxIHiSQ5lwokHcNuQ0S9r0G3yMRrbxTPJfwO7GLHPe9OtkjtO+LScfguBiY6xKSgaDLu+5LYZ4rokENS5zmlsPyMvLDEtKcywTyriW3hyX7XovvkZpd9+Uwz8FdvuM0twTJFeRBAmnOFQJ5ryS3QcK+r8T3SEQr744vIfzu8yrHfa9N9gjt+2rSMTiuBua6hmQg6PKu+1qY51hDUMMSp7nlsLyO/LCENOc6gbzXk9vDkn1fj++RiFYeatcQfmjc4LjvNckeoX3fSDqG5Y3AXDfR5jcsb4Z5ji0OaljiNLcclreQH5aQ5twikPdWcntYsu9b8T0S0cpD7SbCD43bHPe9JtkjtO/bScewvB2Y6w5ym0O8Fu8Q6PWdjq9xfuVEYkN4F+lY43cBc93t+BrntXi3QK/vUbDGJTh+L+lY4/cCc90nvMYRa/E+o5YS/UF/bAa51scCdd0PrF9QF3tIzabedeQv9iDNWSeQ9wFy+2KPfT+A75EolEJA/+OAun5N+qCE1GzqfZA8lCDNeVAg70PkNpTY90P4HolCKQvofzxQ129IH5SQmk29D5OHEqQ5DwvkfYTchhL7fgTfIxGtvKN7iPCXsI+SDhhnA2s5Aajrt6QPxkjNpt7HyMMY0pzHBPI+Tm7DmH0/ju+RiFYeGo8SHsZPkA4YtwHWciJQ1+9IH4yRmk29T5KHMaQ5TwrkfYrchjH7fgrfIxGtPDSeIDyMnyYdMG4LrOUkoK7fkz4YIzWbep8hD2NIc54RyPssuQ1j9v0svkciWnloPE14GD9HOmCcA6zlZKCuP5A+GCM1m3qfJw9jSHOeF8j7ArkNY/b9Ar5HIlp5aDxHeBi/SDpg3A5YyylAXX8kfTBGajb1vkQexpDmvCSQ92VyG8bs+2V8j0S08tB4kfAwfoV0wDgXWMupQF1/In0wRmo29b5KHsaQ5rwqkPc1chvG7Ps1fI9EtPLQeIXwMH6ddMA4DKzlNKCuP5M+GCM1m3rfIA9jSHPeEMj7JrkNY/b9Jr5HIlp5aLxOeBi/RTpgXAis5XSgrr+QPhgjNZt63yYPY0hz3hbI+w65DWP2/Q6+R6JQKgL6nwHU9VfSByWkZlPvu+ShBGnOuwJ53yO3ocS+38P3SBRKxUD/WwN1/Y30QQmp2dT7PnkoQZrzvkDeD8htKLHvD/A9EtHKO7r3CH/Z+iHpgHEJsJYzgbr+TvpgjNRs6v2IPIwhzflIIO/H5DaM2ffH+B6JaOWh8SHhYfwJ6YBxKbCWs4C6/kH6YIzUbOr9lDyMIc35VCDvZ+Q2jNn3Z/geiWjlofEJ4WH8OemAcRmwlrOBuv5J+mCM1Gzq/YI8jCHN+UIg75fkNozZ95f4Holo5aHxOeFh/BXpgHE5sJZzgLr+RfpgjNRs6v2aPIwhzflaIO835DaM2fc3+B6JaOWh8RXhYfwt6YBxe2At5wJ1/Zv0wRip2dT7HXkYQ5rznUDe78ltGLPv7/E9EtHKQ+NbwsP4B8d98/uC3xLw/aPjvnld/iDgmxO67PvHZFK075Djvtffn1rAd5bjvvlWo1kCvrMd9813jcsW8N3Gcd98J7E2Ar7bOu6b7y7VVsB3jrBvxF2RcozdMErrhi5c0OdJ5VuYfOYPI2ZZ58oROK/AhUvE1J56bmvoL0r+nI09bzTHOAcmZ3S9lzbU8hHawBowe5ST9Iz21w6bc33/c6E5q+s4R9ioSap+Ke35xv/PNeoVBtcrZJwzlTcVh8XOW1HBOfIy+M9LoyMvQP95YueN16U8/pz//DQ68gP0ny923ngt5yjI4L8gjY6CAP0XiJ033sA5CjP4L0yjozBA/4Vi541Xco6iDP6L0ugoCtC/qa+1WsObWCv+vLFFnKM4g//iNDqKA/Rv6mut1vAm1oo/bzzOOUoy+C9Jo6MkQP+mvtZqzd/EWvHnjVdxjtIM/kvT6CgN0H+p2HnjizlHWQb/ZWl0lAXo39TXWq2FirSGN7FW/Hmr6zlHeQb/5Wl0lAfov9w4L/p6la8XU9fVjU1LlzXbheBHtvFz6gWIkPE7JpjbGc+i/5pqi0vl3thXvjoAdQ4B6moHfMUwqLcPIDWbenND/u0DkObkhvB5wyG33z7AvsMCL22TtUDM3Btbh45A/0OBuvIUQilPCEr5HkqY5uQLQKnAcSix7wJlUOoE9D8MqKtQIZQKhaBU5KGEaU6RAJSKHYcS+y4WgpLErrNA4I0aJSEdMO4MrOVwoK5ShTAuFYJxmYcxpjllAjAudxzG7LtcCYx5aJQIwLi9Ehh3AdZyBFBXB4Uw7iAE444expjmdBSAcSfHYcy+OymBMQ+N9gIw7qwExl2BtYwAdXVRCOMuQjDu6mGMaU5XARh3cxzG7LubEhjz0OgsAOPuSmDcDVjLKFBXD4Uw7iEE454expjm9BSAcS/HYcy+eymBMQ+N7gIw7q0Ext2BtawA6tpCIYy3EIJxHw9jTHP6CMC4r+MwZt99lcCYh0ZvARj3UwLjHsBaxoC6+iuEcX8hGA/wMMY0Z4AAjAc6DmP2PVAJjHlo9BOA8SAlMO4JrGUlUNdghTAeLATjLT2MMc3ZUgDGQxyHMfseogTGPDQGCcB4qBIY9wHWMg7UNUwhjIcJwXi4hzGmOcMFYDzCcRiz7xFCMDYXiJl7Y+vQF+i/GqgrohBKESEoRT2UMM2JCkCpwnEose8KZVDqB/RfA9QVUwilmBCUKj2UMM2pFIBSleNQYt9VSi5bRyQBir5sjSu5bO0PrGUtUFe1QhhXC8G4xsMY05waARjXOg5j9l2rBMY8NOICMB6pBMYDgLUcCdQ1SiGMRwnBeLSHMaY5owVgPMZxGLPvMUpgzENjpACMxyqB8UBk34G6ximE8TghGI/3MAY1RwDGExyHMfueoATGPDTGCsB4ohIYDwLWcjRQ1ySFMJ4kBOPJHsaY5kwWgPEUx2HMvqcogTEPjYkCMJ6qBMaDgbUcA9Q1TSGMpwnBeCsPY0xzthKA8XTHYcy+pyuBMQ+NqQIwnhFy2ze/L3iogO+tHffN63KGgO+ZQsM3C6yzFzDXLJjnWH1QA3NWSGZgzvYDE9Oc2QIDc47jA5N9zxEamKkHGiS9gbnmwv4oKwLbeeM0twTJNh4kmOZsIwCSeY6DhH3PU7Lz5p3iTIGd2LaO70DnJHuE9r2dkh3odsC/oe1DMhB0edc9Hzcso0ENy/khmWG5gx+WmObsIDAsFzg+LNn3gs14172jwst3nOaWIFnoQYJpzkIBkOzkOEjY905Kdt28O95eYPe5s+O77gXJHqF976Jk170L8G9o181w170bblg2BDUsdwvJDMvd/bDENGd3gWG5yPFhyb4XKRmWPNR2FRgadY4Py3nJHqF9L1YyLBcD/4bqN8Nh2YAblouDGpYNIZlhucQPS0xzlggMyz0cH5bsew8lw5KHWr3A0NhTwbDcQ8D3UiXDcinwb2ivkNsc4rW4l0Cvf+X4Gt9JaEO4t5I1vjdwje/j+BrntbiPQK+XKVjjEhxfrmSNLweu8UbhNY5Yi41C+6rUA/2xmQ7AtT4WqGtf4PoO6mIPqdnU2+Qv9jDNaRK42Fvh+MUe+16hDEodgf7HAXU1K4RSsxCUVnooYZqzUgBK+zkOJfa9nzIodQL6Hw/Utb9CKO0vBKUDPJQwzTlAAEoHOg4l9n2gkpfFVyQBir6EPSikA8adgbWcANR1sEIYHywE41UexpjmrBKA8SGOw5h9H6IExjw0DhKA8aFKYNwFWMuJQF2HKYTxYUIwPtzDGNOcwwVgfITjMGbfRyiBMQ+NQwVgfKQSGHcF1nISUNdRCmF8lBCMj/YwxjTnaAEYH+M4jNn3MUpgzEPjSAEYH6sExt2AtZwM1HWcQhgfJwTj4z2MMc05XgDGJzgOY/Z9ghIY89A4VgDGJyqBcXdgLacAdZ2kEMYnCcH4ZA9jTHNOFoDxKY7DmH2fogTGPDROFIDxqUpg3ANYy6lAXacphPFpQjA+3cMY05zTBWB8huMwZt9nKIExD41TBWB8phIY9wTWchpQ11kKYXyWEIzP9jDGNOdsARif4ziM2fc5SmDMQ+NMARifqwTGfYC1nA7UdZ5CGJ8nBOPzPYwxzTlfAMarHYcx+14tBGNzgZi5N7YOfYH+ZwB1XaAQShcIQelCDyVMcy4UgNIax6HEvtcog1I/oP+tgbouUgili4SgdLGHEqY5FwtA6RLHocS+L1Fy2bo6CVD0ZeulSi5b+wNrOROo6zKFML5MCMZrPYwxzVkrAOPLHYcx+75cCYx5aFwqAOMrlMB4ALCWs4C6rlQI4yuFYHyVhzGmOVcJwPhqx2HMvq9WAmMeGlcIwPgaJTAeCKzlbKCuaxXC+FohGF/nYYxpznUCML7ecRiz7+uVwJiHxjUCML5BCYwHAWs5B6jrRoUwvlEIxjd5GGOac5MAjG92HMbs+2YlMOahcYMAjG9RAuPBwFrOBeq6VSGMbxWC8W0expjm3CYA49sdhzH7vl0JjHlo3CIA4ztCbvvm9wWfK+D7Tsd987q8Q8D3XY775r7cJeD7bsd98/2p7xbwfY/jvvlWo/cI+L7Xcd9817h7BXzf57hvvpPYfQK+73fcN99d6n4B3+uEfSPuirROYI+1oQsX8Hn+u9lfmHwOU8sLDX7k4M8bEbhwiZjaU89tDf1FyZ+zwTXMMc6ByRld76UNtXyENrAGzB7lJD2j/bXD5lzf/1xozuo6zhE2apKqX0p7vvH/c416hcH1ChnnTOVNxWGx81ZUcI68DP7z0ujIC9B/nth543Upjz/nPz+NjvwA/eeLnTdeyzkKMvgvSKOjIED/BWLnjTdwjsIM/gvT6CgM0H+h2HnjlZyjKIP/ojQ6igL0b+prrdbwJtaKP29sEecozuC/OI2O4gD9m/paqzW8ibXizxuPc46SDP5L0ugoCdC/qa+1WvM3sVb8eeNVnKM0g//SNDpKA/RfKnbe+GLOUZbBf1kaHWUB+jf1tVZroSKt4U2sFX/e6nrOUZ7Bf3kaHeUB+i83zou+XuXrxdR1dWPT0mXNdiH4kW38nHoBImT8jgnmdsaz2L+mbmPkDCVFZScFtTUqxe541fJVUeoqgf/ieOdRnBTOtChLVrl94uB7V/OtYvnOjHxDML4PDd/+gL91m7/slb9jkL/aqlfi6J04tkgcfRIHf5kBf3aYP7LGn5QYmDj4fWH8doQtE8eQxDE0cQxLHMMTxwiuQ+Lgl6r4EjeWOHiry6jn0VydOGoSB1/+jEwcoxLH6MQxJnHwPbFTt6CdkDgmJo5JiYO/zZu/RHZq4piWOLZKHPxtLfzlCPxZZP4IHH/ygt/wy+8zm0v//zAb/2zyuUvyeU5jQ9Oi5uVNvZeu6L1seXPvFSsbG5c3NTes/zMaHvoFv3zbL/nl0qxW/vJ/AB6zs2nUFwIA","debug_symbols":"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","file_map":{"25":{"source":"mod hash;\nmod array;\nmod slice;\nmod merkle;\nmod schnorr;\nmod ecdsa_secp256k1;\nmod ecdsa_secp256r1;\nmod eddsa;\nmod grumpkin_scalar;\nmod grumpkin_scalar_mul;\nmod scalar_mul;\nmod sha256;\nmod sha512;\nmod field;\nmod ec;\nmod unsafe;\nmod collections;\nmod compat;\nmod option;\nmod string;\nmod test;\nmod cmp;\nmod ops;\nmod default;\nmod prelude;\nmod uint128;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(_with_newline: bool, _input: T) {}\n\nunconstrained pub fn print<T>(input: T) {\n    print_oracle(false, input);\n}\n\nunconstrained pub fn println<T>(input: T) {\n    print_oracle(true, input);\n}\n\n#[foreign(recursive_aggregation)]\npub fn verify_proof<N>(_verification_key: [Field], _proof: [Field], _public_inputs: [Field], _key_hash: Field) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(_x: T) {}\n// from_field and as_field are private since they are not valid for every type.\n// `as` should be the default for users to cast between primitive types, and in the future\n// traits can be used to work with generic types.\n#[builtin(from_field)]\nfn from_field<T>(_x: Field) -> T {}\n\n#[builtin(as_field)]\nfn as_field<T>(_x: T) -> Field {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) + crate::as_field(y))\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T {\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    crate::from_field(crate::as_field(x) + 340282366920938463463374607431768211456 - crate::as_field(y))\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) * crate::as_field(y))\n}\n","path":"std/lib.nr"},"39":{"source":"global MAX_CONDITIONS = 2;\nglobal MAX_CLAIMS = 2;\n\nstruct Condition {\n    name: str<10>,\n    operator: str<2>,\n    value: Field,\n    issuer: str<8>,\n}\n\nstruct Claim {\n    name: str<10>,\n    value: Field,\n    issuer: str<8>,\n}\n\nstruct AccessControlCriteria {\n    conditions: [Condition; MAX_CONDITIONS],\n    combinations: [str<1>; (MAX_CONDITIONS - 1)],\n}\n\nstruct UnifiedCredential {\n    claims: [Claim; MAX_CLAIMS],\n}\n\nfn check_conditions(criteria: AccessControlCriteria, credential: UnifiedCredential) {\n    let mut previous_check = false;\n    let mut current_check = false;\n\n    for i in 0..criteria.conditions.len() {\n        current_check = false;\n\n        for j in 0..credential.claims.len() {\n            if (criteria.conditions[i].name == credential.claims[j].name)\n                & (criteria.conditions[i].issuer == credential.claims[j].issuer) {\n                if criteria.conditions[i].operator == \"= \" {\n                    current_check = credential.claims[j].value == criteria.conditions[i].value;\n                } else if criteria.conditions[i].operator == \"!=\" {\n                    current_check = credential.claims[j].value != criteria.conditions[i].value;\n                } else {\n                    let claim_value = credential.claims[j].value as u8;\n                    let condition_value = criteria.conditions[i].value as u8;\n\n                    if criteria.conditions[i].operator == \"> \" {\n                        current_check = claim_value > condition_value;\n                    } else if criteria.conditions[i].operator == \"< \" {\n                        current_check = claim_value < condition_value;\n                    } else if criteria.conditions[i].operator == \">=\" {\n                        current_check = claim_value >= condition_value;\n                    } else if criteria.conditions[i].operator == \"<=\" {\n                        current_check = claim_value <= condition_value;\n                    } else {\n                        assert(false, \"Operator is not supported\");\n                        current_check = false;\n                    }\n                }\n            }\n        }\n\n        println(i);\n        // if (!i.lt(1)) {\n        //     let new_i: u8 = i - 1;\n        //     let operator = criteria.combinations[i - 1];\n\n        //     if (operator == \"&\") {\n        //         current_check = previous_check & current_check;\n        //     } else if (operator == \"|\") {\n        //         current_check = previous_check - current_check;\n        //     } else {\n        //         assert(false, \"Combination Operator is not supported\");\n        //         current_check = false;\n        //     }\n        // }\n\n        // assert(current_check);\n        previous_check = current_check;\n    }\n}\n\nfn main(criteria: AccessControlCriteria, credential: UnifiedCredential) {\n    // check the criteria\n    check_conditions(criteria, credential);\n}\n\n#[test]\nfn test_main() {\n    // main(1, 2);\n    // Uncomment to make test fail\n    // main(1, 1);\n}\n","path":"/Users/tuhoang/Repos/zkvc/circuits/vc_presentation_generation/src/main.nr"}}}